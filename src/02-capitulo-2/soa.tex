\subsection{Historia del procesamiento distribuido}
\label{soa:historia}

Los sistemas mainframe de las décadas de 1960 y 1970, como la serie IBM System/360, raramente se comunicaban entre sí, y cuando lo hacían el proceso de transferencia de información de un sistema a otro era realizado por medio de una cinta magnética. Con el tiempo y ante el creciente número de sistemas dentro de las organizaciones, el acceso en tiempo real entre éstos se hizo cada vez más necesario, tanto dentro de la misma organización como fuera de ella, como en el caso de los mercados financieros que requerían realizar transacciones en tiempo real.

Inicialmente, el acceso en tiempo real se lograba vía comunicaciones de socket de bajo nivel, usualmente escritas en lenguaje assembler o C, cuya programación era compleja y requería amplios conocimientos en los protocolos de redes. Luego entraron en escena protocolos como \gls{acro:nfs} y \gls{acro:ftp}, que permitieron abstraerse de la complejidad de los sockets definiendo mecanismos de comunicación que facilitaron el intercambio de información. Estos protocolos dieron pie a abstracciones con aún más posibilidades como \gls{acro:rpc}, un protocolo que permite realizar llamadas a funciones para que sean ejecutadas en un servidor remoto.

En la década de 1980 las computadoras personales habían entrado en escena y los desarrolladores estaban buscando formas más eficaces para aprovechar la potencia de cálculo de estos equipos. Asimismo, el número de servidores dentro de las organizaciones se incrementó exponencialmente debido a la disminución en el precio del hardware. Estas tendencias, junto con la creciente madurez de \gls{acro:rpc}, impulsaron dos importantes avances en la computación distribuida: \gls{acro:corba} y \gls{acro:dcom}, tecnologías que ofrecían herramientas para desarrollar aplicaciones distribuidas en entornos heterogéneos. Todas estas comunicaciones entre las organizaciones eran caras y dependían de líneas alquiladas con propósitos específicos que formaban circuitos privados, lo cual resultaba práctico solamente para las grandes empresas.

A finales de la década de 1990, con la extendida adopción de internet las compañías comenzaron a reconocer los beneficios de expandir sus plataformas digitales a socios y clientes, principalmente por la reducción de costos que este medio implicaba. Desafortunadamente, la utilización de \gls{acro:corba} o \gls{acro:dcom} para las comunicaciones en internet resultó ser todo un reto, en parte debido a las restricciones impuestas por los \eng{firewalls} que sólo permitían el tráfico \gls{proto:http} (necesario para los navegadores y comunicaciones con servidores web), y en parte porque ni \gls{acro:corba}, ni \gls{acro:dcom} lograron dominar el mercado.

Cuando el protocolo \gls{ws:soap} apareció por primera vez en enero de 2000, fue promocionado como la panacea debido a su dependencia interoperable en \gls{lang:xml}. \gls{ws:soap} fue concebido principalmente como una alternativa a \gls{acro:corba} y \gls{acro:dcom} para realizar llamadas remotas a procedimientos. En este sentido, vale la pena señalar que RPC SOAP era una mejora sobre las implementaciones \gls{acro:rpc} anteriores, ya que se basó en \gls{lang:xml} lo que facilitó un mayor grado de interoperabilidad entre los lenguajes de programación.

Si bien el procesamiento distribuido basado en \gls{acro:rpc} fue, sin duda alguna, una mejora sustancial sobre las comunicaciones basadas en sockets de bajo nivel, éste tenía varias limitaciones\cite[p.~6]{opensourcesoa:davis}:

\begin{itemize}
  \item La alta dependencia entre los sistemas locales y remotos requiere demandas de ancho de banda significativo, existiendo la posibilidad de que una excesiva cantidad de llamadas \gls{acro:rpc} de un cliente al servidor puedan generar una carga sustancial en la red.
  \item La naturaleza de grano fino de \gls{acro:rpc} requiere una red altamente predecible. En este sentido, la latencia impredecible, como es el caso de las comunicaciones sobre internet, es inaceptable para las soluciones basadas en \gls{acro:rpc}.
  \item La compatibilidad de tipos de datos de \gls{acro:rpc}, que tiene como objetivo proporcionar un soporte completo para todos los tipos de datos nativos (\texttt{array}, \texttt{string}, \texttt{integer}, etc.), se convierte en una complicación al tratar de compatibilizar lenguajes incompatibles, tales como C++ y Java.
\end{itemize}

Los mensajes RPC SOAP también sufrieron las mismas limitaciones inherentes como las mencionadas anteriormente. Afortunadamente, \gls{ws:soap} ofrece estilos de mensajes alternativos que superan estas deficiencias.

% se puede agregar mas del libro Open Source SOA - Advent of SOA - pp 7-8, hay un gráfico que esta bueno

\subsection{Arquitecturas Orientadas a Servicios}
\label{soa:definicion}

La Arquitectura Orientada a Servicios (\gls{acro:soa}) establece un marco de diseño para la integración de aplicaciones distribuidas e independientes, permitiendo acceder desde la red a sus funcionalidades que se ofrecen como servicio. Habitualmente \gls{acro:soa} es implementado mediante servicios web (\eng{Web Services}), tecnología basada en estándares e independiente de la plataforma que provee los datos, de esta manera \gls{acro:soa} puede descomponer las aplicaciones monolíticas en un conjunto de servicios\cite{microsoft2006}.

Existen varias definiciones de \gls{acro:soa}, muchas incluyen el término \eng{Web Service}, pero éstos conceptos no son lo mismo. \gls{acro:soa} es un paradigma y \eng{Web Service} es una forma posible de implementarlo.

Según Thomas Erl\cite{principlesofdesign:erl}, \gls{acro:soa} establece ``un modelo arquitectónico que tiene como objetivo mejorar la eficiencia, agilidad y productividad de una organización mediante la colocación de los servicios como el principal medio a través del cual se realizan los objetivos estratégicos asociados a la comunicación orientada a servicios''.

Para el Modelo de Referencia \gls{acro:oasis}, \gls{acro:soa} es un paradigma para organizar y utilizar capacidades distribuidas que pueden estar bajo el control de dominios diferentes.

\gls{acro:soa} incluye prácticas y procesos que se basan en el hecho de que los sistemas distribuidos no son controlados por los mismos propietarios. Diferentes equipos, departamentos, o incluso diferentes organizaciones pueden gestionar diferentes sistemas. Este concepto es clave para entender \gls{acro:soa} y grandes sistemas distribuidos.

En el pasado, se han propuesto una gran cantidad de métodos para resolver el problema de la integración de sistemas distribuidos mediante la eliminación de la heterogeneidad, pero sabemos que estos enfoques no funcionan. Los grandes sistemas distribuidos con diferentes propietarios son heterogéneos.  El enfoque \gls{acro:soa} acepta esta heterogeneidad, de manera similar a los métodos ``ágiles'' de desarrollo de software, que aceptan que los requisitos cambian en lugar de tratar de luchar contra esos cambios, \gls{acro:soa} acepta que existe una gran heterogeneidad en los grandes sistemas. No se puede introducir \gls{acro:soa} diseñando todo desde cero. Hay que lidiar con el hecho de que la mayoría de los sistemas legados que se encuentran en producción, se mantendrán\cite[p.~15]{josuttis2007}.
