\subsection{Historia de la Arquitectura de Software}
\label{historia}

Los sistemas mainframe de la década del 60’s y 70’s, como la serie IBM System/360, raramente se comunicaban entre sí.  Cuando las comunicaciones fueron requeridas, el proceso de transferencia de información de un sistema a otro, era realizado por medio de una cinta.  Con el tiempo, sin embargo, el acceso en tiempo real entre sistemas se hizo necesaria, sobre todo porque el número de sistemas dentro de una organización se multiplicaron. Esta necesidad fue especialmente evidente en los mercados financieros, donde se requieren transacciones en tiempo real, que a menudo se extendían a través de las empresas.
Inicialmente, el acceso en tiempo real se lograba vía comunicaciones de socket de bajo nivel, usualmente escritas en lenguaje assembler o C.  La programación de sockets era compleja y requería amplios conocimientos en los protocolos de redes.  Más tarde, entraron en escena protocolos como, \gls{acro:nfs} y \gls{acro:ftp}, que permitieron abstraerse de la complejidad de los sockets.
Empresa como TIBCO desarrollaron un \textit{middleware}, explícitamente diseñado para facilitar las comunicaciones entre servidores.  Con el tiempo, la capacidad de crear aplicaciones distribuidas se hizo posible a través del desarrollo de llamadas a procedimientos remotos \gls{acro:rpc}. \gls{acro:rpc} permitía realizar llamadas a funciones que eran ejecutadas en un servidor remoto.
En la década de 1980, las computadoras personales habían entrado en escena, y los desarrolladores estaban buscando formas más eficaces para aprovechar la potencia de cálculo de escritorio. Como el precio del hardware venía bajando, el número de servidores dentro de la organización se incrementó exponencialmente. Estas tendencias, junto con la creciente madurez de RPC, impulsaron dos importantes avances en la computación distribuida: \gls{acro:corba} y \gls{acro:dcom}).

A finales de los 90’s, con la extendida adopción de internet, las compañías comenzaron a reconocer los beneficios de extender sus plataformas de computación a sus socios y clientes.  Antes de esto, las comunicaciones entre las organizaciones eran caras y dependían de líneas arrendadas (circuitos privados).  Las líneas arrendadas eran poco prácticos, excepto para las grandes empresas.  Desafortunadamente, la utilización de \gls{acro:corba} o \gls{acro:dcom} para las comunicaciones en internet, resultó ser todo un reto, en parte debido a las restricciones impuestas por los cortafuegos que sólo permiten el tráfico \gls{proto:http} (necesario para los navegadores y comunicaciones con servidores web).  Otra razón fue que ni \gls{acro:corba}, ni \gls{acro:dcom}, lograron dominar el mercado.
Cuando el protocolo \gls{ws:soap} apareció por primera vez (en enero de 2000), fue promocionado como una panacea debido a su dependencia interoperable en \gls{lang:xml}. \gls{ws:soap} fue concebido principalmente como una alternativa a \gls{acro:corba} y \gls{acro:dcom}.  Vale la pena señalar que RPC SOAP, era una mejora sobre las implementaciones \gls{acro:rpc} anteriores, ya que se basó en XML, lo que facilita un mayor grado de interoperabilidad entre los lenguajes de programación.

Si bien la computación distribuida basada en \gls{acro:rpc} fue, sin duda, una mejora sustancial sobre las comunicaciones basadas en sockets de bajo nivel, sufría de varias limitaciones:
\begin{itemize}
  \item La alta dependencia entre los sistemas locales y remotos requiere demandas de ancho de banda significativo. Llamadas \gls{acro:rpc} repetidos de un cliente al servidor pueden generar una carga sustancial en la red.
  \item La naturaleza de grano fino de \gls{acro:rpc}, requiere una red altamente predecible. La latencia impredecible, como en las comunicaciones sobre Internet, son inaceptables para las soluciones basadas en \gls{acro:rpc}.
  \item Compatibilidad de tipos de datos de \gls{acro:rpc}, que tiene como objetivo proporcionar un soporte completo para todos los tipos de datos nativos (arrays, cadenas, enteros, etc.), se convierte en un reto al tratar de tender un puente entre lenguajes incompatibles, tales como C++ y Java, a veces estas incompatibilidades complican enormemente su uso.
\end{itemize}

Los mensajes SOAP RPC-style también sufrieron las mismas limitaciones inherentes como las mencionadas anteriormente. Afortunadamente, SOAP ofrece estilos de mensajes alternativos que superen estas deficiencias.

% se puede agregar mas del libro Open Source SOA - Advent of SOA - pp 7-8, hay un gráfico que esta bueno

\subsection{Arquitecturas Orientadas a Servicios}
\label{soa}

La Arquitectura Orientada a Servicios (\gls{acro:soa}) establece un marco de diseño para la integración de aplicaciones independientes permitiendo acceder desde la red a sus funcionalidades, las cuales se ofrecen como servicio.  Habitualmente \gls{acro:soa} es implementado mediante Servicios Web, tecnología basada en estándares e independiente de la plataforma que provee los datos, de esta manera \gls{acro:soa} puede descomponer las aplicaciones monolíticas en un conjunto de servicios.
% citar el párrafor anterior del paper de Microsoft: La arquitectura SOA de Microsoft aplicada al mundo real, esto o redactarlo de otra manera. (pp 2-3)

Existen varias definiciones de \gls{acro:soa}, muchas incluyen el término Web Service, pero \gls{acro:soa} y Web Service no son lo mismo.  \gls{acro:soa} es un paradigma y Web Service es una forma posible de implementar \gls{acro:soa}.

Según Thomas Erl, \gls{acro:soa} establece un modelo arquitectónico que tiene como objetivo mejorar la eficiencia, agilidad y productividad de una organización mediante la colocación de los servicios como el principal medio a través del cual se realizan los objetivos estratégicos asociados a la comutación orientada a servicios.

Para el Modelo de Referencia \gls{acro:oasis}, \gls{acro:soa} es un paradigma para organizar y utilizar capacidades distribuidas que pueden estar bajo el control de dominios diferentes.

\gls{acro:soa} incluye prácticas y procesos que se basan en el hecho de que los sistemas distribuidos no son controlados por los mismos propietarios. Diferentes equipos, departamentos, o incluso diferentes organizaciones pueden gestionar diferentes sistemas. Este concepto es clave para entender \gls{acro:soa} y grandes sistemas distribuidos.

En el pasado, se han propuesto una gran cantidad de métodos para resolver el problema de la integración de sistemas distribuidos mediante la eliminación de la heterogeneidad, pero sabemos que estos enfoques no funcionan. Los grandes sistemas distribuidos con diferentes propietarios son heterogéneos.  El enfoque \gls{acro:soa} acepta esta heterogeneidad, de manera similar a los métodos ``ágiles'' de desarrollo de software, que aceptan que los requisitos cambian en lugar de tratar de luchar contra esos cambios, \gls{acro:soa} acepta que existe una gran heterogeneidad en los grandes sistemas. No se puede introducir \gls{acro:soa} diseñando todo desde cero. Hay que lidiar con el hecho de que la mayoría de los sistemas legados que se encuentran en producción, se mantendrán.
